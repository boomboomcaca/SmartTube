package com.liskovsoft.smartyoutubetv2.common.exoplayer.other;

import android.util.Log;
import com.google.android.exoplayer2.text.Cue;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * 字幕文本处理器
 * 负责字幕文本的分词、解析等处理
 */
public class SubtitleTextProcessor {
    private static final String TAG = SubtitleTextProcessor.class.getSimpleName();
    
    /**
     * 从Cue列表中提取完整的字幕文本
     */
    public static String extractTextFromCues(List<Cue> cues) {
        if (cues == null || cues.isEmpty()) {
            return "";
        }
        
        StringBuilder fullText = new StringBuilder();
        for (Cue cue : cues) {
            if (cue.text != null) {
                String cueText = cue.text.toString();
                // 替换换行符为空格，以便正确处理多行字幕
                cueText = cueText.replace("\n", " ").replace("\r", " ");
                
                if (fullText.length() > 0) {
                    fullText.append(" ");
                }
                fullText.append(cueText);
            }
        }
        
        return fullText.toString();
    }
    
    /**
     * 检查文本是否只包含 CJK 字符
     */
    public static boolean containsOnlyCJK(String text) {
        if (text == null || text.isEmpty()) {
            return false;
        }
        
        for (int i = 0; i < text.length(); i++) {
            char c = text.charAt(i);
            if (!isCJKChar(c) && !Character.isWhitespace(c)) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * 检查字符是否为 CJK 字符
     */
    public static boolean isCJKChar(char c) {
        return (c >= '\u4E00' && c <= '\u9FFF') || // 中文
               (c >= '\u3040' && c <= '\u30FF') || // 日文平假名和片假名
               (c >= '\uAC00' && c <= '\uD7A3');   // 韩文
    }
    
    /**
     * 判断是否是自动生成字幕
     */
    public static boolean isAutoGeneratedSubtitle(String text) {
        if (text == null || text.isEmpty()) {
            return false;
        }
        
        // 自动生成字幕通常具有以下特征:
        // 1. 句子较短（单词数量少）
        // 2. 单词之间的空格规律性强
        // 3. 可能没有标点符号
        
        // 计算单词数量
        String[] words = text.split("\\s+");
        
        // 检查是否有太多单词（自动生成字幕通常只有几个单词）
        if (words.length > 10) {
            return false;
        }
        
        // 检查文本长度（自动生成字幕通常很短）
        if (text.length() > 100) {
            return false;
        }
        
        // 检查是否有句号或问号（结束标点）
        boolean hasEndPunctuation = text.contains(".") || text.contains("?") || text.contains("!");
        
        // 检查首字母是否大写且末尾有句号（完整句子特征）
        boolean isCompleteFormattedSentence = !text.isEmpty() && 
                                            Character.isUpperCase(text.charAt(0)) && 
                                            (text.endsWith(".") || text.endsWith("?") || text.endsWith("!"));
        
        // 综合判断
        return words.length <= 10 && 
               text.length() <= 100 && 
               (!hasEndPunctuation || !isCompleteFormattedSentence);
    }
    
    /**
     * 统一的分词方法
     */
    public static List<String> tokenizeText(String text, boolean isCJK, boolean isAutoGenerated) {
        if (text == null || text.isEmpty()) {
            return new ArrayList<>();
        }
        
        // 处理换行符
        String processedText = text.replace("\n", " ").replace("\r", " ");
        List<String> wordList = new ArrayList<>();
        
        if (isCJK) {
            // CJK文字处理：逐字分词
            tokenizeCJKText(processedText, wordList);
        } else if (isAutoGenerated) {
            // 自动生成字幕处理
            tokenizeAutoGeneratedText(processedText, wordList);
        } else {
            // 普通文本分词
            tokenizeRegularText(processedText, wordList);
        }
        
        return wordList;
    }
    
    /**
     * CJK文字分词
     */
    private static void tokenizeCJKText(String processedText, List<String> wordList) {
        StringBuilder currentWord = new StringBuilder();
        
        for (int i = 0; i < processedText.length(); i++) {
            char c = processedText.charAt(i);
            
            if (isCJKChar(c)) {
                // 如果之前已有非CJK单词在构建中，先添加它
                if (currentWord.length() > 0) {
                    String word = currentWord.toString().trim();
                    if (!word.isEmpty()) {
                        wordList.add(word);
                    }
                    currentWord = new StringBuilder();
                }
                
                // 添加CJK字符作为单独的词
                wordList.add(String.valueOf(c));
            } else if (Character.isWhitespace(c)) {
                // 处理空白字符
                if (currentWord.length() > 0) {
                    String word = currentWord.toString().trim();
                    if (!word.isEmpty()) {
                        wordList.add(word);
                    }
                    currentWord = new StringBuilder();
                }
            } else if (isPunctuation(c)) {
                // 处理标点符号（保留撇号）
                if (currentWord.length() > 0) {
                    String word = currentWord.toString().trim();
                    if (!word.isEmpty()) {
                        wordList.add(word);
                    }
                    currentWord = new StringBuilder();
                }
            } else {
                // 累积非CJK字符
                currentWord.append(c);
            }
        }
        
        // 添加最后一个单词
        if (currentWord.length() > 0) {
            String word = currentWord.toString().trim();
            if (!word.isEmpty()) {
                wordList.add(word);
            }
        }
    }
    
    /**
     * 自动生成字幕分词
     */
    private static void tokenizeAutoGeneratedText(String processedText, List<String> wordList) {
        Pattern wordPattern = Pattern.compile("\\b[\\w']+\\b|[,.!?;:\"\\(\\)\\[\\]\\{\\}]");
        Matcher matcher = wordPattern.matcher(processedText);
        
        while (matcher.find()) {
            String word = matcher.group();
            if (!word.isEmpty()) {
                // 过滤掉单独的标点符号
                if (word.length() == 1 && isPunctuation(word.charAt(0))) {
                    continue;
                }
                wordList.add(word);
            }
        }
        
        // 如果正则匹配没有找到任何单词，退回到简单的空格分割
        if (wordList.isEmpty()) {
            String[] words = processedText.split("\\s+");
            for (String word : words) {
                // 删除首尾的标点符号
                String cleanWord = word.replaceAll("^[,.!?;:\"\\(\\)\\[\\]\\{\\}]+|[,.!?;:\"\\(\\)\\[\\]\\{\\}]+$", "").trim();
                if (!cleanWord.isEmpty()) {
                    wordList.add(cleanWord);
                }
            }
        }
    }
    
    /**
     * 普通文本分词
     */
    private static void tokenizeRegularText(String processedText, List<String> wordList) {
        String[] segments = processedText.split("\\s+");
        for (String segment : segments) {
            if (segment.isEmpty()) {
                continue;
            }
            
            StringBuilder wordBuilder = new StringBuilder();
            
            for (int i = 0; i < segment.length(); i++) {
                char c = segment.charAt(i);
                
                if (isPunctuation(c)) {
                    // 如果已经有单词在构建中，先添加它
                    if (wordBuilder.length() > 0) {
                        String word = wordBuilder.toString().trim();
                        if (!word.isEmpty()) {
                            wordList.add(word);
                        }
                        wordBuilder = new StringBuilder();
                    }
                } else {
                    // 累积字符
                    wordBuilder.append(c);
                }
            }
            
            // 添加最后一个单词
            if (wordBuilder.length() > 0) {
                String word = wordBuilder.toString().trim();
                if (!word.isEmpty()) {
                    wordList.add(word);
                }
            }
        }
    }
    
    /**
     * 检查字符是否是标点符号
     */
    private static boolean isPunctuation(char c) {
        return ",.!?;:\"()[]{}".indexOf(c) >= 0;
    }
    
    /**
     * 计算单词在文本中的位置
     */
    public static int[] calculateWordPositions(String text, List<String> words) {
        int[] positions = new int[words.size()];
        String tempText = text.replace("\n", " ").replace("\r", " ");
        int lastPosition = 0;
        
        for (int i = 0; i < words.size(); i++) {
            String word = words.get(i);
            int position = tempText.indexOf(word, lastPosition);
            
            if (position >= 0) {
                positions[i] = position;
                lastPosition = position + word.length();
            } else {
                positions[i] = -1;
            }
        }
        
        return positions;
    }
}